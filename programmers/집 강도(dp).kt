/**
 * 당신은 거리의 집을 털려는 전문 강도입니다. 각 집에는 일정 금액의 돈이 숨겨져 있습니다. 각각의 집에서 물건을 강탈하는 것을 막는 유일한 제약은 인접한 집에 보안 시스템이 연결되어 있고 같은 밤에 인접한 두 집에 침입한 경우 자동으로 경찰에 연락한다는 것입니다 .
 *
 * nums각 집의 금액을 나타내는 정수 배열이 주어지면 오늘 밤 경찰에 신고하지 않고 훔칠 수 있는 최대 금액을 반환하세요 .
 *
 * 예시 1:
 *
 * 입력: nums = [1,2,3,1]
 *  출력: 4
 *  설명: 1번 집(돈 = 1)을 털고 3번 집(돈 = 3)을 털었습니다.
 * 도둑질할 수 있는 총 금액 = 1 + 3 = 4.
 */

class Solution {
    fun rob(nums: IntArray): Int {
        // 먼저, nums 배열이 비어있는 경우 바로 0을 반환합니다.
        // 이는 아무 집도 털 수 없다는 의미입니다.
        if (nums.isEmpty()) return 0

        // nums 배열에 단 한 집만 있는 경우, 그 집에 있는 돈을 그대로 반환합니다.
        if (nums.size == 1) return nums[0]

        // dp 배열을 생성하고 초기화합니다.
        // dp[i]는 i번째 집까지 고려했을 때 훔칠 수 있는 최대 금액을 저장합니다.
        val dp = IntArray(nums.size).apply {
            // 첫 번째 집을 털 경우, 첫 번째 집에 있는 돈을 dp[0]에 저장합니다.
            this[0] = nums[0]
            // 첫 번째와 두 번째 집 중 더 많은 돈을 가진 집을 털 경우의 금액을 dp[1]에 저장합니다.
            this[1] = maxOf(nums[0], nums[1])
        }

        // 세 번째 집부터 마지막 집까지 각 집을 고려합니다.
        // dp 배열을 업데이트 하며, 각 단계에서의 최적의 해를 찾습니다.
        (2 until nums.size).forEach { i ->
            // i번째 집을 털 경우와 털지 않는 경우 중 더 큰 값을 선택하여 dp[i]에 저장합니다.
            // i번째 집을 털 경우, i-2번째까지의 최대 금액에 i번째 집의 금액을 더합니다.
            // i번째 집을 털지 않는 경우, i-1번째까지의 최대 금액이 그대로 i번째까지의 최대 금액이 됩니다.
            dp[i] = maxOf(dp[i - 2] + nums[i], dp[i - 1])
        }

        // 마지막으로, dp 배열의 마지막 원소를 반환합니다.
        // 이 값은 모든 집을 고려했을 때 훔칠 수 있는 최대 금액입니다.
        return dp.last()
    }
}

