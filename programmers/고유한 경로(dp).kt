/**
 * 그리드 위에 로봇이 있습니다 m x n. 로봇은 처음에 왼쪽 상단 모서리 에 위치합니다 (예: grid[0][0]). 로봇은 오른쪽 하단 모서리 (예: grid[m - 1][n - 1])로 이동하려고 합니다. 로봇은 어느 시점에서든 아래 또는 오른쪽으로만 이동할 수 있습니다.
 * 
 * 두 개의 정수 m및 가 주어지면 로봇이 오른쪽 하단 모서리에 도달하기 위해 취할 수 있는 가능한 고유 경로의 수를n 반환합니다 .
 * 
 * 테스트 케이스는 답이 이하가 되도록 생성됩니다 .2 * 109
 */

class Solution {
    fun uniquePaths(m: Int, n: Int): Int {
        // m x n 그리드의 DP 테이블을 생성하고 모든 값을 1로 초기화합니다.
        var dp = Array(m) { Array(n) { 1 } }

        // 나머지 셀에 대해, 각 셀은 위쪽 셀과 왼쪽 셀의 합입니다.
        // 이는 해당 위치로 오는 경로의 수가 위쪽과 왼쪽에서 오는 경로의 수의 합이기 때문입니다.
        for (i in 1 until m) {
            for (j in 1 until n) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
            }
        }
        // 오른쪽 하단 코너의 값을 반환합니다. 이 값은 모든 유니크한 경로의 수입니다.
        return dp[m - 1][n - 1]
    }
}
