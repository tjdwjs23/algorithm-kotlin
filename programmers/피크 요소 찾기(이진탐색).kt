/**
 * 피크 요소는 인접 요소보다 엄격하게 큰 요소입니다.
 *
 * 0-인덱스 정수 배열이 주어지면 nums피크 요소를 찾고 해당 인덱스를 반환합니다. 배열에 여러 피크가 포함된 경우 피크 중 하나 에 대한 인덱스를 반환합니다 .
 *
 * 당신은 그것을 상상할 수 있습니다 nums[-1] = nums[n] = -∞. 즉, 요소는 항상 배열 외부에 있는 이웃보다 엄격하게 더 큰 것으로 간주됩니다.
 *
 * 시간 에 맞춰 실행되는 알고리즘을 작성해야 합니다 O(log n).
 */


class Solution {
    fun findPeakElement(nums: IntArray): Int {
        // 배열의 시작과 끝을 나타내는 포인터를 초기화합니다.
        var left = 0
        var right = nums.size - 1

        // left가 right보다 작은 동안 반복합니다.
        while (left < right) {
            // 중간 인덱스를 찾습니다. 이는 left와 right의 평균값입니다.
            val mid = left + (right - left) / 2

            // 중간값이 오른쪽 값보다 작은지 확인합니다.
            if (nums[mid] < nums[mid + 1]) {
                // 작다면, 중간값이 피크 요소일 수 없으므로,
                // 검색 범위를 오른쪽 절반으로 좁힙니다.
                left = mid + 1
            } else {
                // 크다면, 중간값이 피크 요소일 수 있으므로,
                // 검색 범위를 왼쪽 절반(또는 중간 포함)으로 좁힙니다.
                right = mid
            }
        }
        // 최종적으로 left는 피크 요소의 인덱스를 가리킵니다.
        // 배열이 오름차순 또는 내림차순으로 정렬되어 있지 않기 때문에,
        // 이 방법으로 피크를 찾을 수 있습니다.
        return left
    }
}
